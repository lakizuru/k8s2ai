#!/usr/bin/env python3
"""
k8s2ai - CLI tool to analyze Kubernetes issues with k8sgpt and execute solutions via kubectl-ai
"""

import json
import subprocess
import sys
import argparse
import re
import os
import threading
import time
from typing import Dict, List, Any, Optional, Tuple

# ANSI color codes
class Colors:
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    
    # Text colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    
    # Bright colors
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'

# Emojis
class Emoji:
    CHECK = 'âœ“'
    CROSS = 'âœ—'
    WARNING = 'âš '
    INFO = 'â„¹'
    ROCKET = 'ðŸš€'
    WRENCH = 'ðŸ”§'
    CLIPBOARD = 'ðŸ“‹'
    MAG = 'ðŸ”'
    BUG = 'ðŸ›'
    LIGHTBULB = 'ðŸ’¡'
    ARROW = 'â†’'
    STAR = 'â­'

# Disable colors if output is not a terminal or NO_COLOR env var is set
def should_colorize():
    return os.getenv('NO_COLOR') is None and sys.stdout.isatty()

def colorize(text: str, color: str) -> str:
    """Apply color to text if colorization is enabled."""
    if should_colorize():
        return f"{color}{text}{Colors.RESET}"
    return text

def bold(text: str) -> str:
    """Make text bold."""
    return colorize(text, Colors.BOLD)


def run_k8sgpt(k8sgpt_args: List[str], need_json: bool = False) -> Tuple[subprocess.CompletedProcess, Optional[Dict[str, Any]]]:
    """Run k8sgpt with provided arguments and return the result and optionally parsed JSON."""
    try:
        # Build the command
        cmd = ["k8sgpt"] + k8sgpt_args
        
        # If we need JSON output, add --output json if not present
        has_output_flag = False
        if need_json:
            for arg in k8sgpt_args:
                if arg in ["--output", "-o"]:
                    has_output_flag = True
                    break
            
            if not has_output_flag:
                cmd.extend(["--output", "json"])
        
        # If we need JSON, stream output live but also capture it
        if need_json:
            # Use Popen to stream output live while capturing it
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                bufsize=1,  # Line buffered
                universal_newlines=True
            )
            
            # Stream output live and capture it
            stdout_chunks = []
            stderr_chunks = []
            
            def read_stdout():
                """Read from stdout in small chunks to preserve progress bars."""
                try:
                    json_started = False
                    while True:
                        # Read in small chunks to preserve \r for progress bars
                        chunk = process.stdout.read(1024)
                        if not chunk:
                            break
                        stdout_chunks.append(chunk)  # Always capture for parsing
                        
                        # Check if JSON has started (look for opening brace)
                        if not json_started:
                            # Check if this chunk contains the start of JSON
                            if '{' in chunk:
                                # Find where JSON starts
                                json_idx = chunk.find('{')
                                # Print everything before JSON
                                if json_idx > 0:
                                    sys.stdout.write(chunk[:json_idx])
                                    sys.stdout.flush()
                                # Don't print the JSON part
                                json_started = True
                            else:
                                # No JSON yet, print everything
                                sys.stdout.write(chunk)
                                sys.stdout.flush()
                        # If JSON has started, don't print it (but it's already in stdout_chunks for parsing)
                except (ValueError, OSError):
                    pass  # Stream closed
            
            def read_stderr():
                """Read from stderr in small chunks."""
                try:
                    while True:
                        chunk = process.stderr.read(1024)
                        if not chunk:
                            break
                        stderr_chunks.append(chunk)
                        # Print stderr immediately
                        sys.stderr.write(chunk)
                        sys.stderr.flush()
                except (ValueError, OSError):
                    pass  # Stream closed
            
            # Start threads to read both streams concurrently
            stdout_thread = threading.Thread(target=read_stdout, daemon=True)
            stderr_thread = threading.Thread(target=read_stderr, daemon=True)
            
            stdout_thread.start()
            stderr_thread.start()
            
            # Wait for process to complete
            returncode = process.wait()
            
            # Wait for threads to finish reading
            stdout_thread.join(timeout=5)
            stderr_thread.join(timeout=5)
            
            # Use captured chunks (which may have JSON filtered out in display)
            stdout = ''.join(stdout_chunks)
            stderr = ''.join(stderr_chunks)
            
            # Create a CompletedProcess-like result
            result = subprocess.CompletedProcess(
                cmd, returncode, stdout, stderr
            )
            
            # If command failed and we added --output json, try without it (in case it's not supported)
            if returncode != 0 and not has_output_flag:
                # Retry without --output json
                cmd_no_output = ["k8sgpt"] + k8sgpt_args
                process = subprocess.Popen(
                    cmd_no_output,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    bufsize=1,
                    universal_newlines=True
                )
                
                stdout_chunks = []
                stderr_chunks = []
                
                def read_stdout_retry():
                    try:
                        while True:
                            chunk = process.stdout.read(1024)
                            if not chunk:
                                break
                            stdout_chunks.append(chunk)
                            sys.stdout.write(chunk)
                            sys.stdout.flush()
                    except (ValueError, OSError):
                        pass
                
                def read_stderr_retry():
                    try:
                        while True:
                            chunk = process.stderr.read(1024)
                            if not chunk:
                                break
                            stderr_chunks.append(chunk)
                            sys.stderr.write(chunk)
                            sys.stderr.flush()
                    except (ValueError, OSError):
                        pass
                
                stdout_thread = threading.Thread(target=read_stdout_retry, daemon=True)
                stderr_thread = threading.Thread(target=read_stderr_retry, daemon=True)
                
                stdout_thread.start()
                stderr_thread.start()
                
                returncode = process.wait()
                
                stdout_thread.join(timeout=5)
                stderr_thread.join(timeout=5)
                
                stdout = ''.join(stdout_chunks)
                stderr = ''.join(stderr_chunks)
                
                result = subprocess.CompletedProcess(
                    cmd_no_output, returncode, stdout, stderr
                )
        else:
            # For non-JSON mode, just run normally (output goes directly to terminal)
            result = subprocess.run(
                cmd,
                text=True,
                check=False
            )
            # When not capturing output, stdout/stderr are None
            stdout = result.stdout if result.stdout is not None else ""
            stderr = result.stderr if result.stderr is not None else ""
        
        # Parse JSON if needed
        parsed_json = None
        if need_json and result.returncode == 0:
            output = stdout.strip()
            
            # Try to parse JSON from stdout
            if output.startswith("{"):
                try:
                    parsed_json = json.loads(output)
                except json.JSONDecodeError:
                    pass
            else:
                # Try to find JSON in the output
                lines = output.split('\n')
                json_start = None
                for i, line in enumerate(lines):
                    if line.strip().startswith('{'):
                        json_start = i
                        break
                
                if json_start is not None:
                    json_str = '\n'.join(lines[json_start:])
                    try:
                        parsed_json = json.loads(json_str)
                    except json.JSONDecodeError:
                        pass
        
        return result, parsed_json
                
    except FileNotFoundError:
        print(colorize(f"{Emoji.CROSS} Error: k8sgpt command not found. Please install k8sgpt first.", Colors.BOLD + Colors.RED), file=sys.stderr)
        sys.exit(1)


def extract_solutions(data: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Extract solutions from k8sgpt output."""
    solutions = []
    
    if not data.get("results"):
        return solutions
    
    for result in data["results"]:
        if result.get("error") and result.get("details"):
            # Parse the details field which contains the solution
            details = result.get("details", "")
            
            # Get error text (handle both single error object and list)
            error_text = "Unknown error"
            error_obj = result.get("error", [])
            if isinstance(error_obj, list) and len(error_obj) > 0:
                error_text = error_obj[0].get("Text", "Unknown error")
            elif isinstance(error_obj, dict):
                error_text = error_obj.get("Text", "Unknown error")
            
            # Split solution into individual steps
            solution_steps = []
            if "Solution:" in details:
                solution_part = details.split("Solution:")[1].strip()
                
                # Try to split by numbered patterns (handles both newline-separated and inline)
                # Pattern matches: "1. text" or "2. text" etc.
                step_pattern = r'(\d+)\.\s+'
                
                # Split by the numbered pattern
                parts = re.split(step_pattern, solution_part)
                
                # Parts will be: ['', '1', 'text for step 1', '2', 'text for step 2', ...]
                # Group them in pairs (number, text)
                i = 1  # Skip the first empty string
                while i < len(parts) - 1:
                    step_num = parts[i]
                    step_text = parts[i + 1].strip()
                    
                    if step_text:
                        # Clean up extra whitespace and newlines
                        step_text = ' '.join(step_text.split())
                        solution_steps.append(step_text)
                    
                    i += 2
                
                # If no numbered steps were found, treat the whole solution as one step
                if not solution_steps:
                    solution_steps = [solution_part.strip()]
            else:
                # If no structured solution, use the whole details as one solution
                solution_steps = [details]
            
            # Create a solution entry for each step
            for idx, step in enumerate(solution_steps, 1):
                solutions.append({
                    "id": len(solutions) + 1,
                    "kind": result.get("kind", "Unknown"),
                    "name": result.get("name", "Unknown"),
                    "error": error_text,
                    "solution": step,
                    "full_details": details
                })
    
    return solutions


def group_solutions_by_error(solutions: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Group solutions by error (kind + name + error text)."""
    grouped = {}
    for sol in solutions:
        # Create a unique key for each error
        key = f"{sol['kind']}|{sol['name']}|{sol['error']}"
        if key not in grouped:
            grouped[key] = []
        grouped[key].append(sol)
    return grouped


def display_errors(grouped: Dict[str, List[Dict[str, Any]]]):
    """Display errors in a user-friendly format."""
    if not grouped:
        print(colorize("No errors found.", Colors.YELLOW))
        return
    
    print("\n" + colorize("="*80, Colors.CYAN))
    print(colorize(f"{Emoji.BUG} DETECTED ISSUES", Colors.BOLD + Colors.CYAN))
    print(colorize("="*80, Colors.CYAN) + "\n")
    
    error_id = 1
    for error_key, error_solutions in grouped.items():
        first_sol = error_solutions[0]
        error_display = first_sol['error'][:150] + "..." if len(first_sol['error']) > 150 else first_sol['error']
        kind_name = f"{first_sol['kind']}: {first_sol['name']}"
        print(colorize(f"[{error_id}]", Colors.BRIGHT_CYAN) + " " + 
              colorize(kind_name, Colors.BOLD + Colors.YELLOW))
        print("    " + colorize(error_display, Colors.RED))
        print()
        error_id += 1


def display_solutions_for_error(error_solutions: List[Dict[str, Any]]):
    """Display solutions for a specific error."""
    if not error_solutions:
        print(colorize("No solutions found for this error.", Colors.YELLOW))
        return
    
    first_sol = error_solutions[0]
    kind_name = f"{first_sol['kind']}: {first_sol['name']}"
    print("\n" + colorize("="*80, Colors.CYAN))
    print(colorize(f"{Emoji.LIGHTBULB} SOLUTIONS FOR: {kind_name}", Colors.BOLD + Colors.CYAN))
    print(colorize("="*80, Colors.CYAN))
    error_display = first_sol['error'][:150] + "..." if len(first_sol['error']) > 150 else first_sol['error']
    print(colorize("Error:", Colors.BOLD + Colors.RED) + " " + colorize(error_display, Colors.RED))
    print("\n" + colorize(f"{Emoji.WRENCH} Solutions:", Colors.BOLD + Colors.GREEN) + "\n")
    
    # Display as a numbered list
    for idx, sol in enumerate(error_solutions, 1):
        sol['display_id'] = idx
        print(colorize(f"{idx}.", Colors.BRIGHT_CYAN) + " " + 
              colorize(sol['solution'], Colors.WHITE))
    print()


def select_error(grouped: Dict[str, List[Dict[str, Any]]]) -> Optional[Tuple[str, List[Dict[str, Any]]]]:
    """Prompt user to select which error to work on."""
    if not grouped:
        return None
    
    error_list = list(grouped.items())
    
    while True:
        try:
            print("\n" + "-"*80)
            choice = input(f"Select an error to work on (1-{len(error_list)}) or 'q' to quit: ").strip()
            
            if choice.lower() == 'q':
                return None
            
            choice_num = int(choice)
            if 1 <= choice_num <= len(error_list):
                return error_list[choice_num - 1]
            else:
                print(f"Please enter a number between 1 and {len(error_list)}")
        except ValueError:
            print("Please enter a valid number or 'q' to quit")
        except KeyboardInterrupt:
            print("\nCancelled.")
            return None


def select_solution(error_solutions: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
    """Prompt user to select a solution or enter a custom one for the selected error."""
    if not error_solutions:
        return None
    
    # Create a mapping from display_id to solution
    id_to_solution = {}
    for sol in error_solutions:
        if 'display_id' in sol:
            id_to_solution[sol['display_id']] = sol
    
    max_id = max(id_to_solution.keys()) if id_to_solution else len(error_solutions)
    
    while True:
        try:
            print("\n" + colorize("-"*80, Colors.DIM))
            prompt_text = colorize(f"{Emoji.ARROW} Select a solution to execute", Colors.BOLD + Colors.CYAN) + \
                         colorize(f" (1-{max_id})", Colors.CYAN) + \
                         colorize(", 'c' for custom solution", Colors.MAGENTA) + \
                         colorize(", or 'q' to quit", Colors.DIM) + ": "
            choice = input(prompt_text).strip()
            
            if choice.lower() == 'q':
                return None
            
            if choice.lower() == 'c':
                # Prompt for custom solution
                return prompt_custom_solution(error_solutions)
            
            choice_num = int(choice)
            if choice_num in id_to_solution:
                return id_to_solution[choice_num]
            elif 1 <= choice_num <= len(error_solutions):
                # Fallback: use index if display_id not found
                return error_solutions[choice_num - 1]
            else:
                print(colorize(f"Please enter a number between 1 and {max_id}, 'c' for custom, or 'q' to quit", Colors.YELLOW))
        except ValueError:
            print(colorize("Please enter a valid number, 'c' for custom solution, or 'q' to quit", Colors.YELLOW))
        except KeyboardInterrupt:
            print("\n" + colorize("Cancelled.", Colors.YELLOW))
            return None


def prompt_custom_solution(solutions: List[Dict[str, Any]]) -> Optional[Dict[str, Any]]:
    """Prompt user to enter a custom solution."""
    if not solutions:
        return None
    
    # Get the first error context (they should all be similar if grouped)
    first_sol = solutions[0]
    
    print("\n" + colorize("-"*80, Colors.DIM))
    print(colorize(f"{Emoji.WRENCH} Enter your custom solution:", Colors.BOLD + Colors.MAGENTA))
    kind_name = f"{first_sol['kind']}: {first_sol['name']}"
    print(colorize("Context:", Colors.BOLD) + " " + colorize(kind_name, Colors.YELLOW))
    error_display = first_sol['error'][:150] + "..." if len(first_sol['error']) > 150 else first_sol['error']
    print(colorize("Error:", Colors.BOLD + Colors.RED) + " " + colorize(error_display, Colors.RED))
    print("\n" + colorize("(Enter your solution text. Press Enter on an empty line to finish, or Ctrl+D/Ctrl+Z)", Colors.DIM))
    
    try:
        custom_solution_lines = []
        
        while True:
            try:
                line = input()
                if line.strip() == "":
                    if custom_solution_lines:
                        # Empty line after content - finish
                        break
                    # Empty line before any content - continue
                    continue
                custom_solution_lines.append(line)
            except EOFError:
                # Ctrl+D (Unix) or Ctrl+Z (Windows) pressed
                break
        
        custom_solution = "\n".join(custom_solution_lines).strip()
        
        if not custom_solution:
            print(colorize("No solution entered. Cancelled.", Colors.YELLOW))
            return None
        
        # Create a solution dict with custom solution
        return {
            "kind": first_sol['kind'],
            "name": first_sol['name'],
            "error": first_sol['error'],
            "solution": custom_solution,
            "full_details": f"Custom solution: {custom_solution}",
            "is_custom": True
        }
    except KeyboardInterrupt:
        print("\n" + colorize("Cancelled.", Colors.YELLOW))
        return None


def execute_with_kubectl_ai(solution: Dict[str, Any]) -> bool:
    """Execute the selected solution using kubectl-ai."""
    print(f"\n{colorize(f'{Emoji.ROCKET} Executing solution with kubectl-ai...', Colors.BOLD + Colors.GREEN)}")
    print(colorize("Solution:", Colors.BOLD) + " " + colorize(solution['solution'], Colors.WHITE))
    print()  # Add blank line before kubectl-ai output
    
    # Construct the prompt for kubectl-ai
    prompt = f"Fix the following Kubernetes issue:\n\n"
    prompt += f"Kind: {solution['kind']}\n"
    prompt += f"Name: {solution['name']}\n"
    prompt += f"Error: {solution['error']}\n\n"
    prompt += f"Apply this solution: {solution['solution']}"
    
    try:
        # Get the current environment and ensure GEMINI_API_KEY is included
        env = os.environ.copy()
        
        # Check if GEMINI_API_KEY is set
        if "GEMINI_API_KEY" not in env:
            print(colorize(f"{Emoji.CROSS} Error: GEMINI_API_KEY environment variable not set.", Colors.BOLD + Colors.RED), file=sys.stderr)
            print(colorize("Please run:", Colors.YELLOW) + " " + colorize("k8s2ai init", Colors.BOLD + Colors.CYAN), file=sys.stderr)
            print(colorize("Or set it manually:", Colors.YELLOW) + " " + colorize('export GEMINI_API_KEY="your-key"', Colors.BOLD + Colors.CYAN), file=sys.stderr)
            return False
        
        # Run kubectl-ai with direct terminal output (no capture)
        # This ensures all output is displayed in real-time
        result = subprocess.run(
            ["kubectl", "ai", "--model", "gemini-2.5-flash", prompt],
            text=True,
            env=env
        )
        
        return result.returncode == 0
            
    except FileNotFoundError:
        print(colorize(f"{Emoji.CROSS} Error: kubectl-ai command not found.", Colors.BOLD + Colors.RED), file=sys.stderr)
        print(colorize("Install with:", Colors.YELLOW) + " " + 
              colorize("kubectl krew install ai", Colors.BOLD + Colors.CYAN), file=sys.stderr)
        return False
    except Exception as e:
        print(colorize(f"{Emoji.CROSS} Error executing solution: {e}", Colors.BOLD + Colors.RED), file=sys.stderr)
        return False


def check_tool_installed(tool_name: str, check_cmd: List[str]) -> bool:
    """Check if a tool is installed."""
    try:
        result = subprocess.run(
            check_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def init_setup():
    """Initialize k8s2ai by checking dependencies and setting up Gemini API."""
    print(colorize(f"\n{Emoji.ROCKET} k8s2ai Initialization", Colors.BOLD + Colors.CYAN))
    print(colorize("="*80, Colors.CYAN) + "\n")
    
    # Check if k8sgpt is installed
    print(colorize(f"{Emoji.MAG} Checking dependencies...", Colors.BOLD))
    
    k8sgpt_installed = check_tool_installed("k8sgpt", ["k8sgpt", "version"])
    if k8sgpt_installed:
        print(colorize(f"  {Emoji.CHECK} k8sgpt is installed", Colors.GREEN))
    else:
        print(colorize(f"  {Emoji.CROSS} k8sgpt is NOT installed", Colors.RED))
        print(colorize("    Install from: https://docs.k8sgpt.ai/getting-started/installation/", Colors.YELLOW))
    
    # Check if kubectl-ai is installed
    kubectl_ai_installed = check_tool_installed("kubectl-ai", ["kubectl", "ai", "--help"])
    if kubectl_ai_installed:
        print(colorize(f"  {Emoji.CHECK} kubectl-ai is installed", Colors.GREEN))
    else:
        print(colorize(f"  {Emoji.CROSS} kubectl-ai is NOT installed", Colors.RED))
        print(colorize("    Install with: kubectl krew install ai", Colors.YELLOW))
    
    # Exit if dependencies are not met
    if not k8sgpt_installed or not kubectl_ai_installed:
        print(colorize(f"\n{Emoji.CROSS} Please install missing dependencies before continuing.", Colors.BOLD + Colors.RED))
        sys.exit(1)
    
    print()
    
    # Prompt for Gemini model selection
    print(colorize(f"\n{Emoji.WRENCH} Setting up Gemini API...", Colors.BOLD))
    print(colorize(f"Available models:", Colors.CYAN))
    print(colorize(f"  1. gemini-2.5-flash (faster, default)", Colors.WHITE))
    print(colorize(f"  2. gemini-2.5-pro (more capable)", Colors.WHITE))
    
    try:
        model_choice = input(colorize("\nSelect model (1/2) [1]: ", Colors.CYAN)).strip()
        
        if not model_choice or model_choice == "1":
            gemini_model = "gemini-2.5-flash"
        elif model_choice == "2":
            gemini_model = "gemini-2.5-pro"
        else:
            print(colorize(f"{Emoji.CROSS} Invalid choice. Using default (gemini-2.5-flash).", Colors.YELLOW))
            gemini_model = "gemini-2.5-flash"
        
        print(colorize(f"Selected model: {gemini_model}", Colors.GREEN))
        
        gemini_api_key = input(colorize("\nEnter your Gemini API key: ", Colors.CYAN)).strip()
        
        if not gemini_api_key:
            print(colorize(f"{Emoji.CROSS} No API key provided. Exiting.", Colors.RED))
            sys.exit(1)
        
        # Export to shell
        print(colorize(f"\n{Emoji.INFO} Exporting GEMINI_API_KEY to environment...", Colors.YELLOW))
        os.environ["GEMINI_API_KEY"] = gemini_api_key
        
        # Determine shell config file
        shell = os.environ.get("SHELL", "")
        home = os.path.expanduser("~")
        
        if "zsh" in shell:
            config_file = os.path.join(home, ".zshrc")
        elif "bash" in shell:
            config_file = os.path.join(home, ".bashrc")
        else:
            config_file = os.path.join(home, ".profile")
        
        # Add export to shell config file
        export_line = f'\nexport GEMINI_API_KEY="{gemini_api_key}"\n'
        config_updated = False
        
        try:
            # Check if already exists
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    content = f.read()
                    if 'GEMINI_API_KEY' in content:
                        print(colorize(f"  {Emoji.INFO} GEMINI_API_KEY already exists in {config_file}", Colors.YELLOW))
                        update = input(colorize("  Update it? (y/N): ", Colors.CYAN)).strip().lower()
                        if update != 'y':
                            print(colorize("  Skipping update to config file.", Colors.YELLOW))
                            # Ask if they want to continue with k8sgpt setup using the new key
                            continue_setup = input(colorize("  Continue with k8sgpt setup using the new API key? (y/N): ", Colors.CYAN)).strip().lower()
                            if continue_setup != 'y':
                                print(colorize(f"\n{Emoji.INFO} Setup cancelled. No changes made.", Colors.YELLOW))
                                return
                            config_updated = True  # They want to use the new key even though file wasn't updated
                        else:
                            # Remove old lines and add new
                            lines = content.split('\n')
                            new_lines = [line for line in lines if 'GEMINI_API_KEY' not in line]
                            with open(config_file, 'w') as f:
                                f.write('\n'.join(new_lines))
                                f.write(export_line)
                            print(colorize(f"  {Emoji.CHECK} Updated {config_file}", Colors.GREEN))
                            config_updated = True
                    else:
                        with open(config_file, 'a') as f:
                            f.write(export_line)
                        print(colorize(f"  {Emoji.CHECK} Added GEMINI_API_KEY to {config_file}", Colors.GREEN))
                        config_updated = True
            else:
                with open(config_file, 'w') as f:
                    f.write(export_line)
                print(colorize(f"  {Emoji.CHECK} Created {config_file} with GEMINI_API_KEY", Colors.GREEN))
                config_updated = True
        except Exception as e:
            print(colorize(f"  {Emoji.WARNING} Could not write to {config_file}: {e}", Colors.YELLOW))
            print(colorize(f"  Please manually add: export GEMINI_API_KEY=\"{gemini_api_key}\"", Colors.YELLOW))
            # Ask if they want to continue anyway
            continue_setup = input(colorize("  Continue with k8sgpt setup anyway? (y/N): ", Colors.CYAN)).strip().lower()
            if continue_setup != 'y':
                print(colorize(f"\n{Emoji.INFO} Setup cancelled.", Colors.YELLOW))
                return
        
        # Configure k8sgpt auth
        print(colorize(f"\n{Emoji.WRENCH} Configuring k8sgpt authentication...", Colors.BOLD))
        
        # Remove existing Google backend if present
        print(colorize(f"  Removing existing Google backend (if any)...", Colors.CYAN))
        subprocess.run(
            ["k8sgpt", "auth", "remove", "--backends", "google"],
            capture_output=True,
            text=True
        )
        # We don't check the return code because it's okay if no backend exists
        
        # Add auth backend
        print(colorize(f"  Adding Google backend with {gemini_model}...", Colors.CYAN))
        result = subprocess.run(
            ["k8sgpt", "auth", "add", "--backend", "google", "--model", gemini_model, "--password", gemini_api_key],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            print(colorize(f"  {Emoji.CHECK} Google backend added successfully", Colors.GREEN))
        else:
            print(colorize(f"  {Emoji.CROSS} Failed to add Google backend", Colors.RED))
            if result.stderr:
                print(colorize(f"  Error: {result.stderr}", Colors.RED))
            sys.exit(1)
        
        # Set default provider
        print(colorize(f"  Setting Google as default provider...", Colors.CYAN))
        result = subprocess.run(
            ["k8sgpt", "auth", "default", "-p", "google"],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            print(colorize(f"  {Emoji.CHECK} Google set as default provider", Colors.GREEN))
        else:
            print(colorize(f"  {Emoji.CROSS} Failed to set default provider", Colors.RED))
            if result.stderr:
                print(colorize(f"  Error: {result.stderr}", Colors.RED))
            sys.exit(1)
        
        print(colorize(f"\n{Emoji.STAR} Initialization complete!", Colors.BOLD + Colors.GREEN))
        print(colorize(f"Model: {gemini_model}", Colors.GREEN))
        print(colorize(f"\n{Emoji.INFO} Note: GEMINI_API_KEY has been set for this session.", Colors.YELLOW))
        print(colorize(f"To use it in other terminal sessions, either:", Colors.YELLOW))
        print(colorize(f"  1. Restart your terminal to load from {config_file}", Colors.DIM))
        print(colorize(f"  2. Or run: source {config_file}", Colors.DIM))
        
    except KeyboardInterrupt:
        print(colorize(f"\n{Emoji.CROSS} Initialization cancelled.", Colors.YELLOW))
        sys.exit(1)
    except Exception as e:
        print(colorize(f"\n{Emoji.CROSS} Error during initialization: {e}", Colors.RED))
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="k8s2ai - Alias for k8sgpt with kubectl-ai integration",
        add_help=False
    )
    parser.add_argument(
        "--auto-select",
        type=int,
        metavar="N",
        help="Automatically select solution N without prompting (requires --explain)"
    )
    
    # Parse known args and capture remaining args for k8sgpt
    args, k8sgpt_args = parser.parse_known_args()
    
    # Check if 'init' command is provided
    if k8sgpt_args and k8sgpt_args[0] == "init":
        init_setup()
        return
    
    # If no k8sgpt args provided, default to "analyze"
    if not k8sgpt_args:
        k8sgpt_args = ["analyze"]
    
    # Check if --explain is present
    has_explain = "--explain" in k8sgpt_args
    
    if has_explain:
        # With --explain: run k8sgpt, parse JSON, show solutions, prompt to pick, execute
        # Note: run_k8sgpt already prints output live (excluding JSON), so we don't need to print it again
        result, data = run_k8sgpt(k8sgpt_args, need_json=True)
        
        # Check for errors
        if result.returncode != 0:
            if result.stderr:
                print(result.stderr, file=sys.stderr)
            sys.exit(result.returncode)
        
        if not data:
            print(colorize(f"{Emoji.CROSS} Error: Could not parse JSON output from k8sgpt", Colors.BOLD + Colors.RED), file=sys.stderr)
            print(colorize(f"Output: {result.stdout}", Colors.YELLOW), file=sys.stderr)
            sys.exit(1)
        
        # Check if there are any problems
        if data.get("status") == "OK" or data.get("problems", 0) == 0:
            print(colorize(f"{Emoji.CHECK} No problems detected!", Colors.BOLD + Colors.GREEN))
            return
        
        # Extract solutions
        solutions = extract_solutions(data)
        
        if not solutions:
            print(colorize(f"{Emoji.INFO} No solutions found in the analysis results.", Colors.YELLOW))
            return
        
        # Group solutions by error
        grouped = group_solutions_by_error(solutions)
        
        # If only one error, skip error selection
        if len(grouped) == 1:
            error_key, error_solutions = list(grouped.items())[0]
            display_solutions_for_error(error_solutions)
            
            # Select solution
            if args.auto_select:
                if 1 <= args.auto_select <= len(error_solutions):
                    selected = error_solutions[args.auto_select - 1]
                else:
                    print(colorize(f"{Emoji.CROSS} Error: Solution number {args.auto_select} is out of range (1-{len(error_solutions)})", Colors.BOLD + Colors.RED), file=sys.stderr)
                    sys.exit(1)
            else:
                selected = select_solution(error_solutions)
            
            if selected:
                # Execute with kubectl-ai
                success = execute_with_kubectl_ai(selected)
                sys.exit(0 if success else 1)
            else:
                print(colorize("No solution selected. Exiting.", Colors.YELLOW))
        else:
            # Multiple errors: first select error, then solution
            display_errors(grouped)
            
            # Select error
            error_selection = select_error(grouped)
            if not error_selection:
                print(colorize("No error selected. Exiting.", Colors.YELLOW))
                return
            
            error_key, error_solutions = error_selection
            display_solutions_for_error(error_solutions)
            
            # Select solution
            if args.auto_select:
                if 1 <= args.auto_select <= len(error_solutions):
                    selected = error_solutions[args.auto_select - 1]
                else:
                    print(colorize(f"{Emoji.CROSS} Error: Solution number {args.auto_select} is out of range (1-{len(error_solutions)})", Colors.BOLD + Colors.RED), file=sys.stderr)
                    sys.exit(1)
            else:
                selected = select_solution(error_solutions)
            
            if selected:
                # Execute with kubectl-ai
                success = execute_with_kubectl_ai(selected)
                sys.exit(0 if success else 1)
            else:
                print(colorize("No solution selected. Exiting.", Colors.YELLOW))
    else:
        # Without --explain: behave exactly like k8sgpt
        # First try to run normally (without forcing JSON)
        result, _ = run_k8sgpt(k8sgpt_args, need_json=False)
        
        # Print the original k8sgpt output (if captured)
        # Note: When not capturing, output goes directly to terminal, so result.stdout is None
        if result.stdout:
            print(result.stdout, end='')
        if result.stderr:
            print(result.stderr, file=sys.stderr)
        
        # Try to parse JSON from output if available (for showing solutions)
        # result.stdout might be None if output wasn't captured
        output = result.stdout.strip() if result.stdout else ""
        data = None
        if output and output.startswith("{"):
            try:
                data = json.loads(output)
            except json.JSONDecodeError:
                pass
        else:
            # Try to find JSON in the output
            lines = output.split('\n')
            json_start = None
            for i, line in enumerate(lines):
                if line.strip().startswith('{'):
                    json_start = i
                    break
            
            if json_start is not None:
                json_str = '\n'.join(lines[json_start:])
                try:
                    data = json.loads(json_str)
                except json.JSONDecodeError:
                    pass
        
        # If we got JSON and there are problems, also show solutions in a nice format
        if data and result.returncode == 0:
            if data.get("status") != "OK" and data.get("problems", 0) > 0:
                solutions = extract_solutions(data)
                if solutions:
                    # Group and display solutions by error
                    grouped = group_solutions_by_error(solutions)
                    print("\n" + colorize("="*80, Colors.CYAN))
                    print(colorize(f"{Emoji.CLIPBOARD} SOLUTIONS SUMMARY", Colors.BOLD + Colors.CYAN))
                    print(colorize("="*80, Colors.CYAN) + "\n")
                    
                    for error_key, error_solutions in grouped.items():
                        first_sol = error_solutions[0]
                        kind_name = f"{first_sol['kind']}: {first_sol['name']}"
                        print(colorize("Error:", Colors.BOLD + Colors.RED) + " " + 
                              colorize(kind_name, Colors.YELLOW))
                        error_display = first_sol['error'][:150] + "..." if len(first_sol['error']) > 150 else first_sol['error']
                        print("  " + colorize(error_display, Colors.RED))
                        print(f"\n  {colorize('Solutions:', Colors.BOLD + Colors.GREEN)}")
                        for idx, sol in enumerate(error_solutions, 1):
                            print("    " + colorize(f"[{idx}]", Colors.BRIGHT_CYAN) + " " + 
                                  colorize(sol['solution'], Colors.WHITE))
                        print()
                    print(colorize("(Use --explain flag to interactively select and execute solutions)", Colors.DIM))
        
        sys.exit(result.returncode)


if __name__ == "__main__":
    main()

